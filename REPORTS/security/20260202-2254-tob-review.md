# Trail of Bits Security Review — Solidity (golem-compute-skill/evm)
Date: 2026-02-02
Reviewer: Connie

## Scope
**Target repo:** golem-compute-skill
**In scope:**
- `evm/src/ConnieToken.sol`
- `evm/src/Counter.sol`
- `evm/script/Counter.s.sol`
- `evm/test/Counter.t.sol`

**Out of scope / third‑party:**
- `evm/lib/**` (forge-std and interfaces)
- `evm/out/**` (build artifacts)

## Methodology (Trail of Bits plugins applied)
- **audit-context-building**: identified trust boundaries and intended use (fork-based integration testing).
- **entry-point-analyzer**: enumerated all external/public entry points.
- **insecure-defaults**: checked for missing access control, zero-address checks, and unsafe defaults.
- **static-analysis**: attempted tool-based scans; performed manual review when tools were unavailable.
- **property-based-testing**: outlined mapping invariants and validated via manual state transition review.

### Tooling / sandbox experiments
- **Codebase mapping:** `find` + `rg "mapping"` to locate all mappings.
- **Dynamic tests:** attempted `forge test` (Foundry) — **not installed** in this environment.
- **Static analysis:** attempted `slither` — **not installed** in this environment.

Recommended sandbox commands (when tools are available):
```bash
cd evm
forge test
slither .
```

## Entry points
- `ConnieToken`: `approve`, `transfer`, `transferFrom`, `mint`
- `Counter`: `setNumber`, `increment`

## Mapping review (ConnieToken)
Mappings:
- `mapping(address => uint256) public balanceOf`
- `mapping(address => mapping(address => uint256)) public allowance`

Manual invariants checked:
- `transfer`/`transferFrom` reduce sender balance before incrementing recipient (no underflow due to require).
- `transferFrom` decreases allowance unless `type(uint256).max` (infinite approval pattern).
- `mint` increases both `totalSupply` and recipient `balanceOf`.

## Findings
### 1) Unrestricted mint (access control)
**Severity:** High (if deployed outside test/fork environment)

**Location:** `evm/src/ConnieToken.sol:32`

**Risk:** Any caller can mint arbitrary supply, bypassing any intended supply constraints. If this token is ever used beyond local fork tests, this enables balance inflation and downstream accounting failures.

**Recommendation:** Gate `mint` behind an owner/role, or remove `mint` entirely for production use. Explicitly document and enforce “test-only” usage.

---
### 2) Missing zero-address guards on transfers/mints
**Severity:** Low

**Location:** `evm/src/ConnieToken.sol:36-44`

**Risk:** `transfer` and `mint` allow `to == address(0)`. This allows accidental token loss and may violate assumptions in downstream logic (some systems treat transfers to zero as burns; this implementation does not reduce `totalSupply`).

**Recommendation:** Add `require(to != address(0), "ZERO_ADDRESS")` in `_transfer` and `mint`, or document zero-address behavior as intentional.

---
### 3) ERC20 approve race condition (standard)
**Severity:** Informational

**Location:** `evm/src/ConnieToken.sol:19-24`

**Risk:** Standard ERC20 allowance race condition exists if a spender front-runs an `approve` change.

**Recommendation:** Consider `increaseAllowance`/`decreaseAllowance` pattern or require allowance to be zero before setting a new non-zero value.

## Non-issues / observations
- No external calls in `ConnieToken` or `Counter` → no reentrancy surface.
- Arithmetic is safe under Solidity `^0.8.20` and guarded by `require` before `unchecked` subtraction.
- `Counter` is minimal and does not introduce exploitable logic.

## Summary
The Solidity surface is small and primarily test-focused. The only material risks are tied to the intentionally minimal ERC20 implementation (unrestricted minting and zero-address handling). If these contracts are ever used beyond fork/testing contexts, access control and stricter ERC20 invariants should be added.
