// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

import { PulseRegistry } from "../contracts/PulseRegistry.sol";
import { MockERC20 } from "./mocks/MockERC20.sol";
import { GasGriefToken } from "./mocks/GasGriefToken.sol";
import { ReentrantERC20 } from "./mocks/ReentrantERC20.sol";
import { FeeOnTransferToken } from "./mocks/FeeOnTransferToken.sol";

interface IFlashBorrower {
    function onFlashLoan(uint256 amount, bytes calldata data) external;
}

contract FlashLender {
    MockERC20 public token;

    constructor(MockERC20 _token) {
        token = _token;
    }

    function flashLoan(address borrower, uint256 amount, bytes calldata data) external {
        uint256 balBefore = token.balanceOf(address(this));
        token.transfer(borrower, amount);
        IFlashBorrower(borrower).onFlashLoan(amount, data);
        uint256 balAfter = token.balanceOf(address(this));
        require(balAfter >= balBefore, "NOT_REPAID");
    }
}

contract FlashBorrower is IFlashBorrower {
    MockERC20 public token;
    PulseRegistry public registry;

    constructor(MockERC20 _token, PulseRegistry _registry) {
        token = _token;
        registry = _registry;
    }

    function onFlashLoan(uint256 amount, bytes calldata data) external override {
        uint256 pulseAmount = abi.decode(data, (uint256));
        token.approve(address(registry), type(uint256).max);
        registry.pulse(pulseAmount);
        token.transfer(msg.sender, amount);
    }
}

contract PulseRegistryExploit is Test {
    PulseRegistry registry;
    MockERC20 token;

    address alice = address(0xA11CE);
    address bob = address(0xB0B);
    address sink = address(0x000000000000000000000000000000000000dEaD);

    uint256 ttl = 1 days;
    uint256 minPulse = 1e18;

    function setUp() public {
        token = new MockERC20("Pulse", "PULSE");
        registry = new PulseRegistry(address(token), sink, ttl, minPulse);

        token.mint(alice, 100e18);
        token.mint(bob, 100e18);

        vm.startPrank(alice);
        token.approve(address(registry), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(bob);
        token.approve(address(registry), type(uint256).max);
        vm.stopPrank();
    }

    function testReentrancyHookTokenBlocked() public {
        ReentrantERC20 hook = new ReentrantERC20("Hook", "HK");
        PulseRegistry r = new PulseRegistry(address(hook), sink, ttl, minPulse);

        address attacker = address(0xCAFE);
        hook.mint(attacker, 5e18);
        hook.mint(address(hook), 5e18);

        vm.startPrank(attacker);
        hook.approve(address(r), type(uint256).max);
        vm.stopPrank();

        bytes memory data = abi.encodeCall(PulseRegistry.pulse, (minPulse));
        hook.enableReenter(address(r), data, address(r));

        vm.prank(attacker);
        r.pulse(minPulse);

        (uint64 lastPulseAt, uint32 streak,,) = r.agents(attacker);
        assertGt(lastPulseAt, 0);
        assertEq(streak, 1);
        assertFalse(hook.reenterSucceeded());
    }

    function testFlashLoanPulseAndRepaySameTx() public {
        FlashLender lender = new FlashLender(token);
        FlashBorrower borrower = new FlashBorrower(token, registry);

        token.mint(address(lender), 50e18);
        token.mint(address(borrower), minPulse); // cover the burn to sink

        bytes memory data = abi.encode(minPulse);
        lender.flashLoan(address(borrower), 10e18, data);

        (uint64 lastPulseAt, uint32 streak,,) = registry.agents(address(borrower));
        assertGt(lastPulseAt, 0);
        assertEq(streak, 1);
        assertEq(token.balanceOf(address(lender)), 50e18);
    }

    function testFrontRunMinPulseAmountIncrease() public {
        uint256 exact = minPulse;
        vm.startPrank(alice);
        token.approve(address(registry), exact);
        vm.stopPrank();

        registry.setMinPulseAmount(minPulse * 2);

        vm.startPrank(alice);
        vm.expectRevert(
            abi.encodeWithSelector(
                PulseRegistry.BelowMinimumPulse.selector,
                exact,
                minPulse * 2
            )
        );
        registry.pulse(exact);
        vm.stopPrank();
    }

    function testUpdateHazardOnNeverPulsedAgent() public {
        address ghost = address(0xF00D);
        (uint64 lastPulseAtBefore,,, uint8 hazardBefore) = registry.agents(ghost);
        assertEq(lastPulseAtBefore, 0);
        assertEq(hazardBefore, 0);

        registry.updateHazard(ghost, 88);

        (uint64 lastPulseAtAfter,,, uint8 hazardAfter) = registry.agents(ghost);
        assertEq(lastPulseAtAfter, 0);
        assertEq(hazardAfter, 88);
    }

    function testPauseUnpauseTiming() public {
        registry.pause();

        vm.startPrank(alice);
        vm.expectRevert();
        registry.pulse(minPulse);
        vm.stopPrank();

        registry.unpause();

        vm.prank(alice);
        registry.pulse(minPulse);
        assertTrue(registry.isAlive(alice));
    }

    function testFeeOnTransferTokenSinkReceivesLess() public {
        address feeCollector = address(0xFEE);
        FeeOnTransferToken feeToken = new FeeOnTransferToken("Fee", "FEE", 1000, feeCollector); // 10%
        PulseRegistry r = new PulseRegistry(address(feeToken), sink, ttl, minPulse);

        address payer = address(0xBEEF);
        feeToken.mint(payer, 10e18);

        vm.startPrank(payer);
        feeToken.approve(address(r), type(uint256).max);
        r.pulse(minPulse);
        vm.stopPrank();

        uint256 sinkBal = feeToken.balanceOf(sink);
        assertLt(sinkBal, minPulse);
        assertEq(feeToken.balanceOf(feeCollector), minPulse - sinkBal);
    }

    function testGasGriefingTokenConsumesExcessiveGas() public {
        GasGriefToken gasToken = new GasGriefToken("Gas", "GAS");
        PulseRegistry r = new PulseRegistry(address(gasToken), sink, ttl, minPulse);

        address attacker = address(0xD00D);
        gasToken.mint(attacker, 10e18);

        vm.startPrank(attacker);
        gasToken.approve(address(r), type(uint256).max);
        vm.stopPrank();

        gasToken.setWasteLoops(5000);

        uint256 gasBefore = gasleft();
        vm.prank(attacker);
        r.pulse{gas: 5_000_000}(minPulse);
        uint256 gasUsed = gasBefore - gasleft();

        assertGt(gasUsed, 200_000);
    }

    function testStreakSameBlockNoIncrease() public {
        vm.startPrank(alice);
        registry.pulse(minPulse);
        registry.pulse(minPulse);
        vm.stopPrank();

        (, uint32 streak,,) = registry.agents(alice);
        assertEq(streak, 1);
    }

    function testStreakDayBoundaryIncrement() public {
        uint256 endOfDay = (block.timestamp / 1 days + 1) * 1 days - 1;
        vm.warp(endOfDay);

        vm.prank(alice);
        registry.pulse(minPulse);

        vm.warp(endOfDay + 1);
        vm.prank(alice);
        registry.pulse(minPulse);

        (, uint32 streak,,) = registry.agents(alice);
        assertEq(streak, 2);
    }

    function testMultiAgentIsolation() public {
        vm.prank(alice);
        registry.pulse(minPulse);

        (uint64 lastPulseAtBob, uint32 streakBob,,) = registry.agents(bob);
        assertEq(lastPulseAtBob, 0);
        assertEq(streakBob, 0);

        vm.prank(bob);
        registry.pulse(minPulse);

        (, uint32 streakAlice,,) = registry.agents(alice);
        (, streakBob,,) = registry.agents(bob);
        assertEq(streakAlice, 1);
        assertEq(streakBob, 1);
    }

    function testMaxParameterBoundaries() public {
        registry.setTTL(registry.MAX_TTL());
        registry.setMinPulseAmount(registry.MAX_MIN_PULSE());

        assertEq(registry.ttlSeconds(), registry.MAX_TTL());
        assertEq(registry.minPulseAmount(), registry.MAX_MIN_PULSE());
    }

    function testOwnershipTransferSafety() public {
        address newOwner = address(0x1234);
        registry.transferOwnership(newOwner);

        vm.startPrank(address(0x9999));
        vm.expectRevert();
        registry.acceptOwnership();
        vm.stopPrank();

        vm.startPrank(newOwner);
        registry.acceptOwnership();
        vm.stopPrank();

        assertEq(registry.owner(), newOwner);

        vm.expectRevert();
        registry.setTTL(2 days);

        vm.prank(newOwner);
        registry.setTTL(2 days);
        assertEq(registry.ttlSeconds(), 2 days);
    }
}
