// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

import { PulseRegistry } from "../contracts/PulseRegistry.sol";
import { RealPulseToken } from "./helpers/RealPulseToken.sol";
import { HookToken } from "./mocks/HookToken.sol";
import { GasGriefToken } from "./mocks/GasGriefToken.sol";

/**
 * @title PulseRegistryExploit Tests
 * @notice Pentest-grade exploit PoC tests for PulseRegistry
 * @dev Part of the 5-agent security audit (Plan v2, approved 2026-02-05)
 */
contract PulseRegistryExploitTest is Test {
    PulseRegistry registry;
    RealPulseToken token;

    address alice = address(0xA11CE);
    address attacker = address(0xBAD);
    address sink = address(0x000000000000000000000000000000000000dEaD);

    uint256 ttl = 86400;
    uint256 minPulse = 1e18;

    function setUp() public {
        uint256 initialSupply = 1_000_000e18;
        token = new RealPulseToken("Pulse", "PULSE", initialSupply, address(this));
        registry = new PulseRegistry(address(token), sink, ttl, minPulse);

        token.transfer(alice, 1000e18);
        token.transfer(attacker, 1000e18);

        vm.prank(alice);
        token.approve(address(registry), type(uint256).max);

        vm.prank(attacker);
        token.approve(address(registry), type(uint256).max);
    }

    // ============ Agent 3, Task 1: Reentrancy via malicious ERC-20 callback ============

    function testReentrancyViaHookToken() public {
        // Deploy a HookToken that calls back into pulse() during transferFrom
        HookToken hookToken = new HookToken("HookPulse", "HPULSE");
        PulseRegistry hookRegistry = new PulseRegistry(address(hookToken), sink, ttl, minPulse);

        hookToken.mint(attacker, 100e18);
        vm.prank(attacker);
        hookToken.approve(address(hookRegistry), type(uint256).max);

        // Set hook to re-enter pulse()
        bytes memory reenterCalldata = abi.encodeWithSelector(
            PulseRegistry.pulse.selector,
            minPulse
        );
        hookToken.setHook(address(hookRegistry), reenterCalldata);

        // The transferFrom happens AFTER state updates (CEI pattern),
        // but even if it happened before, nonReentrant should block it.
        // With our CEI fix, the hook fires during the transfer at the END of pulse().
        // The re-entrant call should revert due to ReentrancyGuard.
        vm.prank(attacker);
        hookRegistry.pulse(minPulse);

        // Verify only ONE pulse was recorded (reentrancy blocked)
        (uint64 lastPulseAt, uint32 streak,,) = hookRegistry.agents(attacker);
        assertEq(streak, 1, "Reentrancy should be blocked - streak should be 1");
        assertGt(lastPulseAt, 0);

        // Verify only minPulse was sent to sink (not 2x)
        assertEq(hookToken.balanceOf(sink), minPulse, "Only one pulse amount should reach sink");
    }

    // ============ Agent 3, Task 2: ERC-777 style tokensToSend hook ============

    function testERC777StyleHookBlocked() public {
        HookToken hookToken = new HookToken("ERC777Sim", "E777");
        PulseRegistry hookRegistry = new PulseRegistry(address(hookToken), sink, ttl, minPulse);

        hookToken.mint(attacker, 100e18);
        vm.prank(attacker);
        hookToken.approve(address(hookRegistry), type(uint256).max);

        // Hook tries to call getAgentStatus during transfer (read-only — should succeed)
        bytes memory readCalldata = abi.encodeWithSelector(
            PulseRegistry.getAgentStatus.selector,
            attacker
        );
        hookToken.setHook(address(hookRegistry), readCalldata);

        vm.prank(attacker);
        hookRegistry.pulse(minPulse);

        // Read-only callback should not corrupt state
        (bool alive,,,) = hookRegistry.getAgentStatus(attacker);
        assertTrue(alive, "Agent should be alive after pulse");
    }

    // ============ Agent 3, Task 3: Flash loan pulse spam ============

    function testFlashLoanPulseSpamNoValue() public {
        // Even if attacker pulses 100 times, each pulse burns tokens
        // There's no extractable value — just activity signal
        vm.startPrank(attacker);
        for (uint256 i = 0; i < 5; i++) {
            registry.pulse(minPulse);
        }
        vm.stopPrank();

        // All tokens burned, no profit for attacker
        assertEq(token.balanceOf(sink), 5 * minPulse);
        assertEq(token.balanceOf(attacker), 1000e18 - 5 * minPulse);

        // Streak is still 1 (same day)
        (, uint32 streak,,) = registry.agents(attacker);
        assertEq(streak, 1);
    }

    // ============ Agent 3, Task 4: Front-running pulse ============

    function testFrontRunningHasNoImpact() public {
        // Alice and attacker pulse in same block — independent state
        vm.prank(alice);
        registry.pulse(minPulse);

        vm.prank(attacker);
        registry.pulse(minPulse);

        // Both have independent streaks
        (, uint32 aliceStreak,,) = registry.agents(alice);
        (, uint32 attackerStreak,,) = registry.agents(attacker);
        assertEq(aliceStreak, 1);
        assertEq(attackerStreak, 1);

        // No ordering dependency — both succeed
        assertTrue(registry.isAlive(alice));
        assertTrue(registry.isAlive(attacker));
    }

    // ============ Agent 3, Task 7: Owner key compromise scenarios ============

    function testOwnerCompromiseDoSTTL() public {
        // Compromised owner sets TTL to max (30 days)
        registry.setTTL(30 days);
        assertEq(registry.ttlSeconds(), 30 days);

        // Cannot set beyond MAX_TTL
        vm.expectRevert(PulseRegistry.InvalidTTL.selector);
        registry.setTTL(31 days);
    }

    function testOwnerCompromiseDoSMinPulse() public {
        // Compromised owner sets minPulse to max (1000 PULSE)
        registry.setMinPulseAmount(1000e18);

        // Alice can't pulse with 1 PULSE anymore
        vm.prank(alice);
        vm.expectRevert(
            abi.encodeWithSelector(PulseRegistry.BelowMinimumPulse.selector, minPulse, 1000e18)
        );
        registry.pulse(minPulse);

        // Cannot set beyond MAX_MIN_PULSE
        vm.expectRevert(PulseRegistry.InvalidMinPulseAmount.selector);
        registry.setMinPulseAmount(1001e18);
    }

    function testOwnerCompromisePause() public {
        // Owner pauses — all pulses blocked
        registry.pause();

        vm.prank(alice);
        vm.expectRevert();
        registry.pulse(minPulse);

        // But Ownable2Step prevents instant transfer to attacker
        registry.transferOwnership(attacker);
        // Owner is still this contract until attacker accepts
        assertEq(registry.owner(), address(this));

        // Attacker must explicitly accept
        vm.prank(attacker);
        registry.acceptOwnership();
        assertEq(registry.owner(), attacker);
    }

    // ============ Agent 3, Task 8: Gas-griefing token test ============

    function testGasGriefingToken() public {
        GasGriefToken griefToken = new GasGriefToken("GriefPulse", "GRIEF");
        PulseRegistry griefRegistry = new PulseRegistry(address(griefToken), sink, ttl, minPulse);

        griefToken.mint(attacker, 100e18);
        vm.prank(attacker);
        griefToken.approve(address(griefRegistry), type(uint256).max);

        // Normal transfer works
        griefToken.setWasteLoops(0);
        vm.prank(attacker);
        uint256 gasBefore = gasleft();
        griefRegistry.pulse(minPulse);
        uint256 gasNormal = gasBefore - gasleft();

        // With 1000 waste loops — still works but costs more gas
        griefToken.setWasteLoops(1000);
        vm.prank(attacker);
        gasBefore = gasleft();
        griefRegistry.pulse(minPulse);
        uint256 gasGrief = gasBefore - gasleft();

        // Gas griefing increases cost but doesn't DoS the protocol
        // The attacker pays for their own gas
        assertGt(gasGrief, gasNormal, "Gas griefing should cost more");

        // Verify state still updated correctly
        (, uint32 streak,,) = griefRegistry.agents(attacker);
        assertEq(streak, 1); // Same day
    }

    // ============ Agent 2, Task 2: Stranded approval scenario ============

    function testStrandedApprovalAfterMinPulseIncrease() public {
        // Alice approves exact amount
        vm.prank(alice);
        token.approve(address(registry), minPulse);

        // Owner increases minPulse
        registry.setMinPulseAmount(2e18);

        // Alice's approval for 1e18 is now below minPulse
        vm.prank(alice);
        vm.expectRevert(
            abi.encodeWithSelector(PulseRegistry.BelowMinimumPulse.selector, minPulse, 2e18)
        );
        registry.pulse(minPulse);

        // Alice must re-approve with higher amount
        vm.startPrank(alice);
        token.approve(address(registry), 2e18);
        registry.pulse(2e18);
        vm.stopPrank();

        assertTrue(registry.isAlive(alice));
    }

    // ============ Agent 2, Task 5: Pause + stranded approval ============

    function testPauseStrandedApproval() public {
        // Alice approves
        vm.prank(alice);
        token.approve(address(registry), type(uint256).max);

        // Admin pauses
        registry.pause();

        // Alice can't pulse while paused
        vm.prank(alice);
        vm.expectRevert();
        registry.pulse(minPulse);

        // Admin unpause
        registry.unpause();

        // Alice can now pulse (approval still valid)
        vm.prank(alice);
        registry.pulse(minPulse);
        assertTrue(registry.isAlive(alice));
    }

    // ============ Agent 1: uint32 truncation check ============

    function testUint32DayTruncation() public {
        // block.timestamp / 86400 should not overflow uint32 for ~300 years
        // uint32 max = 4,294,967,295 days = ~11.7 million years from epoch
        // Verify current range is safe
        uint256 farFuture = 365 days * 300; // 300 years from now
        vm.warp(block.timestamp + farFuture);

        uint32 dayValue = uint32(block.timestamp / 86400);
        assertGt(dayValue, 0, "Day value should be positive");

        // Verify pulse works at far future timestamp
        vm.prank(alice);
        registry.pulse(minPulse);

        (, uint32 streak, uint32 lastStreakDay,) = registry.agents(alice);
        assertEq(streak, 1);
        assertEq(lastStreakDay, dayValue);
    }

    // ============ Agent 4: signalSink immutability ============

    function testSignalSinkIsImmutable() public {
        // signalSink is set in constructor and cannot be changed
        assertEq(registry.signalSink(), sink);
        // No setter exists — verified by ABI (there is no setSignalSink function)
    }

    function testPulseTokenIsImmutable() public {
        // pulseToken is set in constructor and cannot be changed
        assertEq(address(registry.pulseToken()), address(token));
        // No setter exists — verified by ABI
    }
}
